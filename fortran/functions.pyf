
!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module _fortran ! in

  usercode '''
  #include "fortran/functionsmodule.h"
  '''
  interface  ! in :_fortran

      subroutine pitVolume(deplocal,pitidg,nb,voldep,m)

          integer intent(in) :: nb
          real(kind=8) dimension(m),intent(in) :: deplocal
          integer dimension(m),intent(in),depend(m) :: pitidg
          real(kind=8) dimension(nb),intent(out),depend(nb) :: voldep
          integer, optional,check(len(deplocal)>=m),depend(deplocal) :: m=len(deplocal)

      end subroutine pitVolume

      subroutine pitHeight(elev,fillz,pitidg,percdep,newz,m,nb)

          real(kind=8) dimension(m),intent(in) :: elev
          real(kind=8) dimension(m),intent(in),depend(m) :: fillz
          integer dimension(m),intent(in),depend(m) :: pitidg
          real(kind=8) dimension(nb),intent(in) :: percdep
          real(kind=8) dimension(m),intent(out),depend(m) :: newz
          integer, optional,check(len(elev)>=m),depend(elev) :: m=len(elev)
          integer, optional,check(len(percdep)>=nb),depend(percdep) :: nb=len(percdep)

      end subroutine pitHeight

      subroutine addExcess(elev,downsed,deplocal,m,n)

        real(kind=8) dimension(m),intent(in) :: elev
        real(kind=8) dimension(n,2),intent(in) :: downsed
        real(kind=8) dimension(m),intent(out),depend(m) :: deplocal
        integer, optional,check(len(elev)>=m),depend(elev) :: m=len(elev)
        integer, optional,check(len(downsed)>=n),depend(downsed) :: n=len(downsed)

      end subroutine addExcess

      subroutine fillDepression(dem,fillp,wsh,graph,spillpit,area,idloc,elev,dID,vol,cPit,m,nb)

          real(kind=8) dimension(m),intent(in) :: dem
          real(kind=8) dimension(m),intent(in),depend(m) :: fillp
          integer dimension(m),intent(in),depend(m) :: wsh
          real(kind=8) dimension(nb),intent(in) :: graph
          integer dimension(nb),intent(in) :: spillpit
          real(kind=8) dimension(m),intent(in),depend(m) :: area
          integer dimension(m),intent(in),depend(m) :: idloc
          real(kind=8) dimension(m),intent(out),depend(m) :: elev
          real(kind=8) dimension(nb),intent(out),depend(nb) :: vol
          integer dimension(nb,nb),intent(out),depend(nb,nb) :: cPit
          integer dimension(m),intent(out),depend(m) :: dID
          integer, optional,check(len(dem)>=m),depend(dem) :: m=len(dem)
          integer, optional,check(len(graph)>=nb),depend(graph) :: nb=len(graph)

      end subroutine fillDepression

      subroutine combinePit(nb,m,cPit,locvol,pID,order,gPit,gID,gVol,gOver)

          integer :: nb
          integer :: m
          integer dimension(nb,nb),intent(in),depend(nb,nb) :: cPit
          real(kind=8) dimension(nb),intent(in),depend(nb) :: locvol
          integer dimension(nb),intent(in),depend(nb) :: order
          integer dimension(m),intent(in),depend(m) :: pID
          integer dimension(nb),intent(out),depend(nb) :: gPit
          integer dimension(m),intent(out),depend(m) :: gID
          real(kind=8) dimension(nb),intent(out),depend(nb) :: gVol
          integer dimension(nb),intent(out),depend(nb) :: gOver

      end subroutine combinePit

      subroutine meanSlope(elev,bid,gbounds,bslp,nb,b)

          real(kind=8) dimension(nb),intent(in) :: elev
          integer dimension(b),intent(in) :: bid
          integer dimension(nb),intent(in),depend(nb) :: gbounds
          real(kind=8) dimension(nb,12),intent(in),depend(nb) :: elght
          real(kind=8) dimension(nb),intent(out),depend(nb) :: bslp
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)
          integer, optional,check(len(bid)>=b),depend(bid) :: b=len(bid)

      end subroutine meanSlope

      subroutine flatBounds(elev,erodep,bid,gbounds,be,bd,nb,b)

          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: erodep
          integer dimension(b),intent(in) :: bid
          integer dimension(nb),intent(in),depend(nb) :: gbounds
          real(kind=8) dimension(nb),intent(out),depend(nb) :: be
          real(kind=8) dimension(nb),intent(out),depend(nb) :: bd
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)
          integer, optional,check(len(bid)>=b),depend(bid) :: b=len(bid)

      end subroutine flatBounds

      subroutine slpBounds(elev,erodep,bid,gbounds,be,bd,nb,b)

          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: erodep
          integer dimension(b),intent(in) :: bid
          integer dimension(nb),intent(in),depend(nb) :: gbounds
          real(kind=8) dimension(nb),intent(out),depend(nb) :: be
          real(kind=8) dimension(nb),intent(out),depend(nb) :: bd
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)
          integer, optional,check(len(bid)>=b),depend(bid) :: b=len(bid)

      end subroutine slpBounds

      subroutine setHillslopeCoeff(nb,kd,dcoeff)

          integer intent(in) :: nb
          real(kind=8) intent(in) :: kd
          real(kind=8) dimension(nb,13),intent(out),depend(nb) :: dcoeff

      end subroutine setHillslopeCoeff

      subroutine setDiffusionCoeff(kd,limit,elev,elev0,dh,dcoeff,nb)

          real(kind=8) intent(in) :: kd
          real(kind=8) intent(in) :: limit
          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: elev0
          real(kind=8) dimension(nb),intent(in) :: dh
          real(kind=8) dimension(nb,13),intent(out),depend(nb) :: dcoeff
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)

      end subroutine setDiffusionCoeff

      subroutine distributeHeight(inids,sl,elev,elev0,sed,nelev,nsed,nb)

          integer dimension(nb),intent(in) :: inids
          real(kind=8) intent(in) :: sl
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev0
          real(kind=8) dimension(nb),intent(in),depend(nb) :: sed
          real(kind=8) dimension(nb),intent(out),depend(nb) :: nelev
          real(kind=8) dimension(nb),intent(out),depend(nb) :: nsed
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine distributeHeight

      subroutine distributeVolume(inids,sl,elev,elev0, sed,nsed,nb)

          integer dimension(nb),intent(in) :: inids
          real(kind=8) intent(in) :: sl
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev0
          real(kind=8) dimension(nb),intent(in),depend(nb) :: sed
          real(kind=8) dimension(nb),intent(out),depend(nb) :: nsed
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine distributeVolume

      subroutine diffusionDT(dm,hlocal,hl0,bounds,iters,itflx,inids,sflux,skd,okd,sl,ierr,nb)

        integer(kind=HANDLE_KIND), intent(in)  :: dm
        integer(kind=HANDLE_KIND), intent(in) :: hl0
        integer(kind=HANDLE_KIND), intent(inout)  :: hlocal
        integer dimension(nb),intent(in) :: inids
        integer dimension(nb),intent(in),depend(nb) :: bounds
        integer intent(in) :: iters
        integer intent(in) :: itflx
        real(kind=8) dimension(nb,12),intent(in),depend(nb) :: skd
        real(kind=8) dimension(nb,12),intent(in),depend(nb) :: okd
        real(kind=8) dimension(nb),intent(in),depend(nb) :: sflux
        real(kind=8),intent(in) :: sl
        integer, intent(out) ::   ierr
        integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine diffusionDT

      subroutine minHeight(inids,elev,hmin,nb)

          integer dimension(nb),intent(in) :: inids
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          real(kind=8) dimension(nb),intent(out),depend(nb) :: hmin
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine minHeight

      subroutine singlePit(inids,bounds,elev,nelev,shore,nb)

          integer dimension(nb),intent(in) :: inids
          integer dimension(nb),intent(in) :: bounds
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          real(kind=8) dimension(nb),intent(out),depend(nb) :: nelev
          integer dimension(nb),intent(out),depend(nb) :: shore
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine singlePit

      subroutine MFDreceivers(nrcv,inids,elev,rcv,slope,dist,wgt,nb)

          integer intent(in) :: nrcv
          integer dimension(nb),intent(in) :: inids
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          integer dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: rcv
          real(kind=8) dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: slope
          real(kind=8) dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: dist
          real(kind=8) dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: wgt
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine MFDreceivers

      subroutine defineTIN(coords,cells_nodes,cells_edges,edges_nodes,area,circumcenter,ngbnb,ngbid,edgelgt,vorodist,n,nb,m)

          real(kind=8) dimension(nb,3),intent(in) :: coords
          integer dimension(n,3),intent(in) :: cells_nodes
          integer dimension(n,3),intent(in),depend(n) :: cells_edges
          integer dimension(m,2),intent(in) :: edges_nodes
          real(kind=8) dimension(nb),intent(in),depend(nb) :: area
          real(kind=8) dimension(3,n),intent(in),depend(n) :: circumcenter
          integer dimension(nb),intent(out),depend(nb) :: ngbnb
          integer dimension(nb,12),intent(out),depend(nb) :: ngbid
          real(kind=8) dimension(nb,12),intent(out),depend(nb) :: edgelgt
          real(kind=8) dimension(nb,12),intent(out),depend(nb) :: vorodist
          integer, optional,check(shape(cells_nodes,0)==n),depend(cells_nodes) :: n=shape(cells_nodes,0)
          integer, optional,check(shape(coords,0)==nb),depend(coords) :: nb=shape(coords,0)
          integer, optional,check(shape(edges_nodes,0)==m),depend(edges_nodes) :: m=shape(edges_nodes,0)

      end subroutine defineTIN

  end interface

end python module _fortran
