!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module _fortran ! in

  usercode '''
  #include "fortran/functionsmodule.h"
  '''
  interface  ! in :_fortran

      subroutine pitVolume(deplocal,pitid,pitnb,pitvol,notpitvol,m)

          real(kind=8) dimension(m),intent(in) :: deplocal
          integer dimension(m),intent(in),depend(m) :: pitid
          integer intent(in) :: pitnb
          real(kind=8) dimension(pitnb),intent(out),depend(pitnb) :: pitvol
          real(kind=8) dimension(m),intent(out),depend(m) :: notpitvol
          integer, optional,check(len(deplocal)>=m),depend(deplocal) :: m=len(deplocal)

      end subroutine pitVolume

      subroutine pitHeight(elev,fillz,pitid,pitvol,pitsedvol,newz,remain,totnodes,m,nn,nb)

          real(kind=8) dimension(m),intent(in) :: elev
          real(kind=8) dimension(m),intent(in),depend(m) :: fillz
          integer dimension(m),intent(in),depend(m) :: pitid
          real(kind=8) dimension(nn),intent(in) :: pitvol
          real(kind=8) dimension(nb),intent(in) :: pitsedvol
          real(kind=8) dimension(m),intent(out),depend(m) :: newz
          real(kind=8) dimension(nb),intent(out),depend(nb) :: remain
          integer dimension(nb),intent(out),depend(nb) :: totnodes
          integer, optional,check(len(elev)>=m),depend(elev) :: m=len(elev)
          integer, optional,check(len(pitvol)>=nn),depend(pitvol) :: nn=len(pitvol)
          integer, optional,check(len(pitsedvol)>=nb),depend(pitsedvol) :: nb=len(pitsedvol)

      end subroutine pitHeight

      subroutine addExcess(excess,pitid,addvol,m,n)

          real(kind=8) dimension(n),intent(in) :: excess
          integer dimension(m),intent(in) :: pitid
          real(kind=8) dimension(m),intent(out),depend(m) :: addvol
          integer, optional,check(len(excess)>=n),depend(excess) :: n=len(excess)
          integer, optional,check(len(pitid)>=m),depend(pitid) :: m=len(pitid)

      end subroutine addExcess

      subroutine fillDepression(dem,fillp,wsh,graph,area,elev,dID,vol,cPit,m,nb)

          real(kind=8) dimension(m),intent(in) :: dem
          real(kind=8) dimension(m),intent(in),depend(m) :: fillp
          integer dimension(m),intent(in),depend(m) :: wsh
          real(kind=8) dimension(nb),intent(in) :: graph
          real(kind=8) dimension(m),intent(in),depend(m) :: area
          real(kind=8) dimension(m),intent(out),depend(m) :: elev
          real(kind=8) dimension(nb),intent(out),depend(nb) :: vol
          integer dimension(nb,nb),intent(out),depend(nb,nb) :: cPit
          integer dimension(m),intent(out),depend(m) :: dID
          integer, optional,check(len(dem)>=m),depend(dem) :: m=len(dem)
          integer, optional,check(len(graph)>=nb),depend(graph) :: nb=len(graph)

      end subroutine fillDepression

      subroutine combinePit(nb,m,cPit,locvol,pID,order,gPit,gID,gVol,gOver)

          integer :: nb
          integer :: m
          integer dimension(nb,nb),intent(in),depend(nb,nb) :: cPit
          real(kind=8) dimension(nb),intent(in),depend(nb) :: locvol
          integer dimension(nb),intent(in),depend(nb) :: order
          integer dimension(m),intent(in),depend(m) :: pID
          integer dimension(nb),intent(out),depend(nb) :: gPit
          integer dimension(m),intent(out),depend(m) :: gID
          real(kind=8) dimension(nb),intent(out),depend(nb) :: gVol
          integer dimension(nb),intent(out),depend(nb) :: gOver

      end subroutine combinePit

      subroutine meanSlope(elev,bid,gbounds,bslp,nb,b)

          real(kind=8) dimension(nb),intent(in) :: elev
          integer dimension(b),intent(in) :: bid
          integer dimension(nb),intent(in),depend(nb) :: gbounds
          real(kind=8) dimension(nb,12),intent(in),depend(nb) :: elght
          real(kind=8) dimension(nb),intent(out),depend(nb) :: bslp
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)
          integer, optional,check(len(bid)>=b),depend(bid) :: b=len(bid)

      end subroutine meanSlope

      subroutine flatBounds(elev,erodep,bid,gbounds,be,bd,nb,b)

          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: erodep
          integer dimension(b),intent(in) :: bid
          integer dimension(nb),intent(in),depend(nb) :: gbounds
          real(kind=8) dimension(nb),intent(out),depend(nb) :: be
          real(kind=8) dimension(nb),intent(out),depend(nb) :: bd
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)
          integer, optional,check(len(bid)>=b),depend(bid) :: b=len(bid)

      end subroutine flatBounds

      subroutine slpBounds(elev,erodep,bid,gbounds,be,bd,nb,b)

          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: erodep
          integer dimension(b),intent(in) :: bid
          integer dimension(nb),intent(in),depend(nb) :: gbounds
          real(kind=8) dimension(nb),intent(out),depend(nb) :: be
          real(kind=8) dimension(nb),intent(out),depend(nb) :: bd
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)
          integer, optional,check(len(bid)>=b),depend(bid) :: b=len(bid)

      end subroutine slpBounds

      subroutine setHillslopeCoeff(nb,kd,dcoeff)

          integer intent(in) :: nb
          real(kind=8) intent(in) :: kd
          real(kind=8) dimension(nb,13),intent(out),depend(nb) :: dcoeff

      end subroutine setHillslopeCoeff

      subroutine setDiffusionCoeff(kd,elev,dh,nelev,nb)

          real(kind=8) intent(in) :: kd
          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: dh
          real(kind=8) dimension(nb),intent(out),depend(nb) :: nelev
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)

      end subroutine setDiffusionCoeff

      !subroutine setDiffusionCoeff2(kd,elev,dh,dcoeff,nb)

      !    real(kind=8) intent(in) :: kd
      !    real(kind=8) dimension(nb),intent(in) :: elev
      !    real(kind=8) dimension(nb),intent(in) :: dh
      !    real(kind=8) dimension(nb,13),intent(out),depend(nb) :: dcoeff
      !    integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)

      !end subroutine setDiffusionCoeff2

      subroutine initDiffCoeff(nb,dt,kds,kdm,sc,sm,mindt)

          integer intent(in) :: nb
          real(kind=8) intent(in) :: dt
          real(kind=8) intent(in) :: kds
          real(kind=8) intent(in) :: kdm
          real(kind=8) dimension(nb),intent(in) :: area
          integer dimension(nb),intent(in),depend(nb) :: ngbnb
          real(kind=8) dimension(nb,12),intent(in),depend(nb) :: lgth
          real(kind=8) dimension(nb,12),intent(in),depend(nb) :: vlgth
          real(kind=8) dimension(nb,12),intent(out),depend(nb) :: sc
          real(kind=8) dimension(nb,12),intent(out),depend(nb) :: sm
          real(kind=8) intent(out) :: mindt

      end subroutine initDiffCoeff

      subroutine diffusionDT(dm,hlocal,hl0,bounds,iters,itflx,inids,sflux,skd,okd,sl,ierr,nb)

        integer(kind=HANDLE_KIND), intent(in)  :: dm
        integer(kind=HANDLE_KIND), intent(in) :: hl0
        integer(kind=HANDLE_KIND), intent(inout)  :: hlocal
        integer dimension(nb),intent(in) :: inids
        integer dimension(nb),intent(in),depend(nb) :: bounds
        integer intent(in) :: iters
        integer intent(in) :: itflx
        real(kind=8) dimension(nb,12),intent(in),depend(nb) :: skd
        real(kind=8) dimension(nb,12),intent(in),depend(nb) :: okd
        real(kind=8) dimension(nb),intent(in),depend(nb) :: sflux
        real(kind=8),intent(in) :: sl
        integer, intent(out) ::   ierr
        integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine diffusionDT

      subroutine minHeight(inids,elev,hmin,nb)

          integer dimension(nb),intent(in) :: inids
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          real(kind=8) dimension(nb),intent(out),depend(nb) :: hmin
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine minHeight

      subroutine singlePit(inids,bounds,elev,nelev,nb)

          integer dimension(nb),intent(in) :: inids
          integer dimension(nb),intent(in) :: bounds
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          real(kind=8) dimension(nb),intent(out),depend(nb) :: nelev
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine singlePit

      subroutine MFDreceivers(nrcv,inids,elev,rcv,shore,slope,dist,wgt,nb)

          integer intent(in) :: nrcv
          integer dimension(nb),intent(in) :: inids
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          integer dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: rcv
          integer dimension(nb),intent(out),depend(nb) :: shore
          real(kind=8) dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: slope
          real(kind=8) dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: dist
          real(kind=8) dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: wgt
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine MFDreceivers

      subroutine defineTIN(coords,cells_nodes,cells_edges,edges_nodes,area,circumcenter,ngbnb,ngbid,edgelgt,vorodist,n,nb,m)

          real(kind=8) dimension(nb,3),intent(in) :: coords
          integer dimension(n,3),intent(in) :: cells_nodes
          integer dimension(n,3),intent(in),depend(n) :: cells_edges
          integer dimension(m,2),intent(in) :: edges_nodes
          real(kind=8) dimension(nb),intent(in),depend(nb) :: area
          real(kind=8) dimension(3,n),intent(in),depend(n) :: circumcenter
          integer dimension(nb),intent(out),depend(nb) :: ngbnb
          integer dimension(nb,12),intent(out),depend(nb) :: ngbid
          real(kind=8) dimension(nb,12),intent(out),depend(nb) :: edgelgt
          real(kind=8) dimension(nb,12),intent(out),depend(nb) :: vorodist
          integer, optional,check(shape(cells_nodes,0)==n),depend(cells_nodes) :: n=shape(cells_nodes,0)
          integer, optional,check(shape(coords,0)==nb),depend(coords) :: nb=shape(coords,0)
          integer, optional,check(shape(edges_nodes,0)==m),depend(edges_nodes) :: m=shape(edges_nodes,0)

      end subroutine defineTIN

  end interface

end python module _fortran
