
!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module _fortran ! in

  usercode '''
  #include "fortran/functionsmodule.h"
  '''
  interface  ! in :_fortran

      subroutine meanSlope(elev,bid,gbounds,bslp,nb,b)

          real(kind=8) dimension(nb),intent(in) :: elev
          integer dimension(b),intent(in) :: bid
          integer dimension(nb),intent(in),depend(nb) :: gbounds
          real(kind=8) dimension(nb,12),intent(in),depend(nb) :: elght
          real(kind=8) dimension(nb),intent(out),depend(nb) :: bslp
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)
          integer, optional,check(len(bid)>=b),depend(bid) :: b=len(bid)

      end subroutine meanSlope

      subroutine flatBounds(elev,erodep,bid,gbounds,be,bd,nb,b)

          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: erodep
          integer dimension(b),intent(in) :: bid
          integer dimension(nb),intent(in),depend(nb) :: gbounds
          real(kind=8) dimension(nb),intent(out),depend(nb) :: be
          real(kind=8) dimension(nb),intent(out),depend(nb) :: bd
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)
          integer, optional,check(len(bid)>=b),depend(bid) :: b=len(bid)

      end subroutine flatBounds

      subroutine slpBounds(elev,erodep,bid,gbounds,be,bd,nb,b)

          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: erodep
          integer dimension(b),intent(in) :: bid
          integer dimension(nb),intent(in),depend(nb) :: gbounds
          real(kind=8) dimension(nb),intent(out),depend(nb) :: be
          real(kind=8) dimension(nb),intent(out),depend(nb) :: bd
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)
          integer, optional,check(len(bid)>=b),depend(bid) :: b=len(bid)

      end subroutine slpBounds

      subroutine setHillslopeCoeff(nb,kd,dcoeff)

          integer intent(in) :: nb
          real(kind=8) intent(in) :: kd
          real(kind=8) dimension(nb,13),intent(out),depend(nb) :: dcoeff

      end subroutine setHillslopeCoeff

      subroutine setDiffusionCoeff(kd,limit,elev,elev0,dh,dcoeff,nb)

          real(kind=8) intent(in) :: kd
          real(kind=8) intent(in) :: limit
          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: elev0
          real(kind=8) dimension(nb),intent(in) :: dh
          real(kind=8) dimension(nb,13),intent(out),depend(nb) :: dcoeff
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)

      end subroutine setDiffusionCoeff

      subroutine explicitDiff(kd,limit,elev,elev0,dh,newz,nb)

          real(kind=8) intent(in) :: kd
          real(kind=8) intent(in) :: limit
          real(kind=8) dimension(nb),intent(in) :: elev
          real(kind=8) dimension(nb),intent(in) :: elev0
          real(kind=8) dimension(nb),intent(in) :: dh
          real(kind=8) dimension(nb),intent(out),depend(nb) :: newz
          integer, optional,check(len(elev)>=nb),depend(elev) :: nb=len(elev)

      end subroutine explicitDiff

      subroutine distributeHeight(inids,sl,elev,elev0,sed,nelev,nsed,nb)

          integer dimension(nb),intent(in) :: inids
          real(kind=8) intent(in) :: sl
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev0
          real(kind=8) dimension(nb),intent(in),depend(nb) :: sed
          real(kind=8) dimension(nb),intent(out),depend(nb) :: nelev
          real(kind=8) dimension(nb),intent(out),depend(nb) :: nsed
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine distributeHeight

      subroutine distributeVolume(inids,sl,elev,elev0, sed,nsed,nb)

          integer dimension(nb),intent(in) :: inids
          real(kind=8) intent(in) :: sl
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev0
          real(kind=8) dimension(nb),intent(in),depend(nb) :: sed
          real(kind=8) dimension(nb),intent(out),depend(nb) :: nsed
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine distributeVolume

      subroutine diffusionDT(dm,hlocal,hl0,bounds,iters,itflx,inids,sflux,skd,okd,sl,ierr,nb)

        integer(kind=HANDLE_KIND), intent(in)  :: dm
        integer(kind=HANDLE_KIND), intent(in) :: hl0
        integer(kind=HANDLE_KIND), intent(inout)  :: hlocal
        integer dimension(nb),intent(in) :: inids
        integer dimension(nb),intent(in),depend(nb) :: bounds
        integer intent(in) :: iters
        integer intent(in) :: itflx
        real(kind=8) dimension(nb,12),intent(in),depend(nb) :: skd
        real(kind=8) dimension(nb,12),intent(in),depend(nb) :: okd
        real(kind=8) dimension(nb),intent(in),depend(nb) :: sflux
        real(kind=8),intent(in) :: sl
        integer, intent(out) ::   ierr
        integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine diffusionDT

      subroutine minHeight(inids,elev,hmin,nb)

          integer dimension(nb),intent(in) :: inids
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          real(kind=8) dimension(nb),intent(out),depend(nb) :: hmin
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine minHeight

      subroutine pitData(rank,pnode,inids,natural,tmp3,nb,nb1,nb2)

          integer ,intent(in) :: rank
          integer dimension(nb),intent(in) :: pnode
          integer dimension(nb1),intent(in) :: inids
          integer dimension(nb2),intent(in) :: natural
          integer dimension(2*nb),intent(out),depend(nb) :: tmp3
          integer, optional,check(len(pnode)>=nb),depend(pnode) :: nb=len(pnode)
          integer, optional,check(len(inids)>=nb1),depend(inids) :: nb1=len(inids)
          integer, optional,check(len(inids)>=nb2),depend(natural) :: nb2=len(natural)

      end subroutine pitData

      subroutine MFDreceivers(nrcv,inids,elev,rcv,slope,dist,wgt,nb)

          integer intent(in) :: nrcv
          integer dimension(nb),intent(in) :: inids
          real(kind=8) dimension(nb),intent(in),depend(nb) :: elev
          integer dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: rcv
          real(kind=8) dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: slope
          real(kind=8) dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: dist
          real(kind=8) dimension(nb,nrcv),intent(out),depend(nb,nrcv) :: wgt
          integer, optional,check(len(inids)>=nb),depend(inids) :: nb=len(inids)

      end subroutine MFDreceivers

      subroutine defineTIN(coords,cells_nodes,cells_edges,edges_nodes,area,circumcenter,ngbnb,ngbid,edgelgt,vorodist,n,nb,m)

          real(kind=8) dimension(nb,3),intent(in) :: coords
          integer dimension(n,3),intent(in) :: cells_nodes
          integer dimension(n,3),intent(in),depend(n) :: cells_edges
          integer dimension(m,2),intent(in) :: edges_nodes
          real(kind=8) dimension(nb),intent(in),depend(nb) :: area
          real(kind=8) dimension(3,n),intent(in),depend(n) :: circumcenter
          integer dimension(nb),intent(out),depend(nb) :: ngbnb
          integer dimension(nb,12),intent(out),depend(nb) :: ngbid
          real(kind=8) dimension(nb,12),intent(out),depend(nb) :: edgelgt
          real(kind=8) dimension(nb,12),intent(out),depend(nb) :: vorodist
          integer, optional,check(shape(cells_nodes,0)==n),depend(cells_nodes) :: n=shape(cells_nodes,0)
          integer, optional,check(shape(coords,0)==nb),depend(coords) :: nb=shape(coords,0)
          integer, optional,check(shape(edges_nodes,0)==m),depend(edges_nodes) :: m=shape(edges_nodes,0)

      end subroutine defineTIN

      subroutine defineGTIN(nb,cells_nodes,edges_nodes,ngbnb,ngbid,n,m)

          integer ,intent(in) :: nb
          integer dimension(n,3),intent(in) :: cells_nodes
          integer dimension(m,2),intent(in) :: edges_nodes
          integer dimension(nb),intent(out),depend(nb) :: ngbnb
          integer dimension(nb,12),intent(out),depend(nb) :: ngbid
          integer, optional,check(shape(cells_nodes,0)==n),depend(cells_nodes) :: n=shape(cells_nodes,0)
          integer, optional,check(shape(edges_nodes,0)==m),depend(edges_nodes) :: m=shape(edges_nodes,0)

      end subroutine defineGTIN

  end interface

end python module _fortran
